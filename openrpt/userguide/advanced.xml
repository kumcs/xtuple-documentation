<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter>
  <title id="i564782">Advanced Topics</title>
  <para>In this chapter we will cover a range of advanced topics. We touched
  on some of these topics in earlier chapters. Others will be presented here
  for the first time. Subjects covered in this chapter include the
  following:</para>
  <itemizedlist>
    <listitem>
      <para>MetaSQL</para>
    </listitem>
    <listitem>
      <para>MetaSQL editor</para>
    </listitem>
    <listitem>
      <para>Report renderer</para>
    </listitem>
    <listitem>
      <para>Watermarks and background images</para>
    </listitem>
    <listitem>
      <para>Barcodes</para>
    </listitem>
    <listitem>
      <para>Graphs</para>
    </listitem>
  </itemizedlist>
  <section>
    <title>MetaSQL</title>
    <para>MetaSQL is a scripting language developed by xTuple for use by the
    report writer. The language is designed to handle dynamic database
    queries. MetaSQL statements are embedded within standard SQL—for example,
    within the query source of a report definition. When a report is run, a
    parsing engine interprets the MetaSQL using a list of named parameters.
    The parsed result is standard SQL, which in turn is sent to the target
    database. The following diagram illustrates this process:</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_metaSQL.png"/>
          </imageobject>
          <caption>MetaSQL Parser handles embedded MetaSQL</caption>
        </mediaobject>
      </screenshot></para>
    <para>Dynamic queries are queries which contain conditional statements.
    Query results will vary depending on how the conditions are satisfied. For
    example, a report may return one result if a user makes one selection—or a
    different result if the user makes a different selection. The report
    results are conditional upon choices made by the user. The MetaSQL
    scripting language enables you to allow for and incorporate this
    conditionality into your report definitions.</para>
    <section>
      <title>MetaSQL in Practice</title>
      <para>To illustrate how dynamic, conditional queries are handled using
      MetaSQL, let's examine a sample report definition called
      "UsersMasterList". This is the same report definition we have worked
      with in previous chapters.</para>
      <para>The UsersMasterList report definition is called whenever someone
      using the xTuple application wants to print a copy of the Users master
      list. That xTuple master list appears in the following
      screenshot:</para>
      <para id="i565640"><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_100_UsersSession.png"/>
            </imageobject>
            <caption>Master list of xTuple Users</caption>
          </mediaobject>
        </screenshot></para>
      <para>When someone selects the <guibutton>PRINT</guibutton> button, the
      information displayed on the screen is printed out using the
      UsersMasterList report definition.</para>
      <para>If you look closely, you can see the option <guilabel>Show
      Inactive Users</guilabel> is selected. As a result, the Users master
      list is displaying both active and inactive users. The <guilabel>Show
      Inactive Users</guilabel> option is an example of a dynamic condition.
      If the option is selected, one list of users will be displayed. If it’s
      not selected, another list of users will be displayed. Logically, the
      report definition must accommodate either of these two
      conditions.</para>
      <para>The report definition uses MetaSQL to handle these conditions.
      Let's look at the query source for the UsersMasterList report definition
      to understand how MetaSQL is embedded within a report definition:</para>
      <para id="i565925"><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_105_UsersQuery.png"/>
            </imageobject>
            <caption>Query source for UsersMasterList report
            definition</caption>
          </mediaobject>
        </screenshot></para>
      <para>To locate embedded MetaSQL in a query source, simply look for the
      <literal>&lt;?</literal> and <literal>?&gt;</literal> tags. These are
      the tags used to identify MetaSQL statements. As you can see, the
      <literal>WHERE</literal> clause contains several MetaSQL tags.</para>
      <para>Let’s examine the <literal>WHERE</literal> clause to gain a better
      understanding for how MetaSQL works:</para>
      <programlisting>WHERE ((usr_locale_id=locale_id)
&lt;? if not exists("showInactive") ?&gt;
    AND (usr_active=true)
&lt;? endif ?&gt;
)
</programlisting>
      <simpara>The MetaSQL is always contained inside <literal>&lt;?</literal>
      and <literal>?&gt;</literal> tags. Our sample <literal>WHERE</literal>
      clause contains the following two lines of MetaSQL:</simpara>
      <orderedlist>
        <listitem>
          <para><literal>&lt;? if not exists("showInactive")
          ?&gt;</literal></para>
        </listitem>
        <listitem>
          <para><literal>&lt;? endif ?&gt;</literal></para>
        </listitem>
      </orderedlist>
      <simpara>MetaSQL statements:</simpara>
      <variablelist>
        <varlistentry>
          <term>if not</term>
          <listitem>
            <para>This statement begins a MetaSQL condition.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>endif</term>
          <listitem>
            <para>This statement ends the condition.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <simpara>MetaSQL function:</simpara>
      <variablelist>
        <varlistentry>
          <term>exists</term>
          <listitem>
            <para>This MetaSQL function takes the name of the parameter
            provided. In this case, the provided parameter is named
            <literal>showInactive</literal>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <simpara>Parameters:</simpara>
      <variablelist>
        <varlistentry>
          <term>showInactive</term>
          <listitem>
            <para>The conditionality of the report centers on this parameter.
            It is this parameter which determines whether inactive users
            should be included in the report. Like all valid parameters
            referenced in a MetaSQL statement, the parameter
            <literal>showInactive</literal>. The
            <literal>showInactive</literal> parameter originates from within
            the source code of the application utilizing the report writer. In
            this case, that application is xTuple—and the parameter is
            included in the source code for the Users master list screen. When
            an xTuple user sends a print request from the Users master list
            screen, the MetaSQL parser interprets the existing
            conditions—namely, is the <literal>showInactive</literal>
            parameter being used, or not? The parser then uses this
            information to produce standard SQL meeting the specified
            conditions. This standard SQL, which has been stripped of its
            MetaSQL elements by the parser, is then delivered to the target
            database for processing.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <tip>
        <para>The xTuple application automatically generates a parameter list
        whenever a user submits a print request. The parameter list will
        contain as many (or as few) parameters as pertain to the screen the
        print request was sent from. When a MetaSQL statement in an xTuple
        report definition refers to a parameter, that parameter should be one
        which would appear on the generated parameter list.</para>
      </tip>
      <simpara>Resulting SQL:</simpara>
      <para>If a user selects the <guilabel>Show Inactive Users</guilabel>
      option, the MetaSQL parser will send the following standard SQL to the
      target database:</para>
      <programlisting>SELECT usr_username,
       usr_propername,
       usr_initials,
       formatBoolYN(usr_active) AS
f_active,
       formatBoolYN(usr_agent) AS
f_pa,
       locale_code
FROM usr, locale
WHERE ((usr_locale_id=locale_id)
AND (usr_active=true))
ORDER BY usr_username;
</programlisting>
      <para>If the user does not select the <guilabel>Show Inactive
      Users</guilabel> option, the MetaSQL parser will send the following
      standard SQL to the target database:</para>
      <programlisting>SELECT usr_username,
       usr_propername,
       usr_initials,
       formatBoolYN(usr_active) AS
f_active,
       formatBoolYN(usr_agent) AS
f_pa,
       locale_code
FROM usr, locale
WHERE ((usr_locale_id=locale_id)
ORDER BY usr_username;
</programlisting>
      <note>
        <para>You may have noticed the <literal>AND</literal> is excluded in
        the second example. This occurs because in the second example the
        value of the parameter "showInactive" is false.</para>
      </note>
      <para>As the "UsersMasterList" example demonstrates, static report
      definitions can be made to handle dynamic conditions using MetaSQL. In
      the following sections, we will examine the range of MetaSQL building
      blocks.</para>
    </section>
    <section>
      <title>MetaSQL Syntax</title>
      <para>MetaSQL syntax is comprised of control statements and functions.
      Control statements contain standard SQL which will be used if certain
      conditions are met. Functions are generally used to evaluate parameters.
      Collectively, control statements and functions are referred to as
      <emphasis>statements</emphasis>. When these statements are embedded
      within standard SQL, they create MetaSQL.</para>
      <para>As we have mentioned previously, MetaSQL statements are bracketed
      between an opening angle bracket and question mark pair
      ("<literal>&lt;?</literal>") and a closing question mark and angle
      bracket pair ("<literal>?&gt;</literal>"). All content within (and
      including) the opening and closing character pairs is referred to as a
      <emphasis>tag</emphasis>. Each tag is comprised of a single statement
      and also any additional arguments, parameters, or modifiers which apply
      to the statement. The first word following the tag opening (i.e.,
      "<literal>&lt;?</literal>") is the statement. Any additional text after
      the statement up to the closing angle bracket
      ("<literal>?&gt;</literal>") is broken into tokens and processed
      accordingly.</para>
      <tip>
        <para>You don't need to worry about inserting excess blank spaces when
        writing MetaSQL statements. The MetaSQL parser ignores excess blank
        spaces.</para>
      </tip>
      <para>Next we will look at the range of available control statements and
      functions, offering descriptions for how each may be used.</para>
      <section>
        <title>Control Statements</title>
        <para>Control statements form blocks which contain standard SQL and
        MetaSQL tags. While control statements are not directly responsible
        for producing output, they do determine whether their contents should
        be outputted or not. The complete list of available MetaSQL control
        statements is described below:</para>
        <variablelist>
          <varlistentry>
            <term>if</term>
            <listitem>
              <para>Use the <literal>if</literal> statement to begin a
              conditional control block. One token should follow this opening
              statement. You can reverse the boolean result of a token by
              placing a <literal>not</literal> token directly proceeding the
              token. If the token is a <literal>true</literal> value, then the
              contents of the <literal>if</literal> block will be executed. If
              the condition is <literal>false</literal>, then the next
              following <literal>elseif</literal> condition will be evaluated,
              assuming one exists.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>elseif</term>
            <listitem>
              <para>Place an <literal>elseif</literal> statement within an
              <literal>if</literal> block to divide the <literal>if</literal>
              block into multiple blocks. An <literal>elseif</literal>
              statement behaves in the same manner as an <literal>if</literal>
              statement. Any number of <literal>elseif</literal> conditions
              may be included within an <literal>if</literal> block.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>else</term>
            <listitem>
              <para>An else condition, if present, is executed when both the
              <literal>if</literal> condition and any
              <literal>elseif</literal> conditions are false. At most, there
              may be one <literal>else</literal> condition included within an
              <literal>if</literal> block.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>endif</term>
            <listitem>
              <para>Use this statement to end an <literal>if</literal>
              block.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>foreach</term>
            <listitem>
              <para>This statement operates on the parameter which immediately
              follows it. If the parameter represents a list of values, the
              <literal>foreach</literal> block will be executed once for each
              value in the list. If the parameter represents a single value,
              then the block will be executed once. If no values exists, the
              block will not be executed.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>endforeach</term>
            <listitem>
              <para>Use this statement to end a <literal>foreach</literal>
              block.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section>
        <title>Functions</title>
        <para>Functions are independent statements which perform specific
        operations. If a function returns a value, the value will be
        outputted. The complete list of available MetaSQL functions is
        described below:</para>
        <variablelist>
          <varlistentry>
            <term>value</term>
            <listitem>
              <para>This function operates on the parameter which immediately
              follows it and returns the value of that parameter. If the
              parameter is called within a <literal>foreach</literal> block
              and the parameter represents a list, the function will return
              the current item of that list. If the parameter is called
              outside of a <literal>foreach</literal> block and the parameter
              represents a list, the value will default to the first entry. If
              the parameter named does not exist, then a blank or null value
              will be returned.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>exists</term>
            <listitem>
              <para>This function operates on the parameter which immediately
              follows it and returns true if that parameter exists. If the
              parameter does not exist, then the function returns false. If
              the parameter is null or blank, the function will still return
              true because the parameter exists.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>reExists</term>
            <listitem>
              <para>This function takes a regular expression and returns true
              if one or more parameter exists which match the regular
              expression. The regular expression is case-sensitive.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>isFirst</term>
            <listitem>
              <para>his function operates on the parameter which immediately
              follows it. If the parameter is called inside a
              <literal>foreach</literal> block and the parameter represents a
              list, the function will return true if the item returned by the
              call would be the first item in the list. If the parameter is
              called outside a <literal>foreach</literal> block—or if the
              parameter specified does not represent a list but does
              exist—then the function will return true. In all other
              situations, the function will return false.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>isLast</term>
            <listitem>
              <para>This function operates on the parameter which immediately
              follows it. If the parameter is called inside a
              <literal>foreach</literal> block and the parameter represents a
              list, the function will return true if the item returned by the
              call would be the last item in the list. If the parameter is
              called outside a <literal>foreach</literal> block and the
              parameter represents a list, the function will return true only
              if the list contains one item. In all cases, the function will
              return true if the parameter does not represent a list, but
              instead represents a single parameter. If the parameter does not
              exist—or in any other case—this function will return
              false.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>continue</term>
            <listitem>
              <para>This function will cause the innermost loop to execute to
              the end and continue as normal. If this statement is used
              outside of a loop, the function has no effect. If a number is
              specified, the specified number determines how many loops will
              be continued. If the number of specified loops is greater than
              the number of nested loops, then the function will continue the
              outermost loop.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>break</term>
            <listitem>
              <para>This function will cause the current loop to execute to
              the end and stop. If the function is used outside of a loop, the
              function will have no effect. If the number of loops is
              specified, that determines how many loops will be terminated. If
              the number of loops to break is greater than the number of
              nested loops, then all loops will broken.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
  </section>
  <section>
    <title>MetaSQL Editor</title>
    <para>As we have seen, MetaSQL is a non-standard language embedded within
    standard SQL. MetaSQL cannot be executed directly on a database, but must
    first pass through and be interpreted by the MetaSQL parser. The MetaSQL
    parser then generates standard SQL which is sent to the target database
    for processing.</para>
    <para>The MetaSQL Editor is a tool designed to facilitate the process of
    writing report definitions having MetaSQL elements. Using the MetaSQL
    Editor, report authors can develop complex queries, test them with
    different values for parameters, and then view the resulting standard SQL.
    Report authors can save time and effort using the MetaSQL Editor to test
    any portion of a complex query having MetaSQL elements.</para>
    <note>
      <para>The MetaSQL Editor is a multi-platform tool, running identically
      on Windows, Linux, and Mac. For testing report definitions linked to the
      xTuple application, the MetaSQL binary file should be installed in the
      same directory as the xTuple client.</para>
    </note>
    <para>The example we will be using in this section focuses on running the
    MetaSQL Editor against an xTuple database. However, the MetaSQL Editor
    source code can be modified to work with other database
    applications.</para>
    <section>
      <title>Connecting to a Database</title>
      <para>The MetaSQL Editor can be an extremely useful tool for report
      authors who want to test the accuracy of their MetaSQL statements during
      the process of writing report definitions. To open the MetaSQL Editor,
      run it from the location where it is installed. The following screen
      will appear:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_110_MsqlEditor.png"/>
            </imageobject>
            <caption>MetaSQL Editor</caption>
          </mediaobject>
        </screenshot></para>
      <para>To perform tests using the MetaSQL Editor, you must first connect
      to your target database. To connect to a database, select the
      <guimenuitem>Database</guimenuitem> option from the
      <guimenu>File</guimenu> submenu, as shown in the following
      screen:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_115_ConnectDb.png"/>
            </imageobject>
            <caption>Connecting to a database</caption>
          </mediaobject>
        </screenshot></para>
      <para>For the purposes of this example, we will be connecting to an
      xTuple database. That explains why, when we select the
      <guimenuitem>Connect</guimenuitem> option, we are brought to a database
      login screen which has been customized for the xTuple
      application:</para>
      <para id="i571974"><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_200_MetaSQL_Logon.png"/>
            </imageobject>
            <caption>MetaSQL Editor - connecting to the database</caption>
          </mediaobject>
        </screenshot></para>
      <para>Under the <guibutton>OPTIONS</guibutton> button, we specify our
      server, database, and port connection information. And then, we are
      asked to enter a valid username and password.</para>
      <para>Once we have successfully connected to our target database, we can
      begin testing the accuracy of embedded MetaSQL statements using the
      MetaSQL Editor.</para>
    </section>
    <section>
      <title>Entering a Query</title>
      <para>For this exercise, we will demonstrate the MetaSQL Editor
      functionality using a very basic and simple query. The goal of the
      exercise is to leave you with an understanding of fundamental MetaSQL
      Editor mechanics. You are free to perform more complex and extensive
      testing on your own.</para>
      <para>Now that we are connected to a database—in this case, an xTuple
      database—we can write a simple query and then test the results. To enter
      a query, simply type in the MetaSQL Editor's main text field, as shown
      in the following screen:</para>
      <para id="i570586"><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_210_MetaSQL_SQL_IN.png"/>
            </imageobject>
            <caption>Simple SQL query with embedded MetaSQL</caption>
          </mediaobject>
        </screenshot></para>
      <note>
        <para>Test queries may be saved for future use by selecting either the
        <guimenuitem>Save</guimenuitem> or <guimenuitem>Save As</guimenuitem>
        options from the <guimenu>File</guimenu> menu.</para>
      </note>
      <para>As you can see, the query begins with standard SQL. We are seeking
      to <literal>SELECT</literal> four pieces of item information <emphasis
      role="bold">from</emphasis> the <literal>item</literal> table. Our
      MetaSQL is inserted within the <literal>WHERE</literal> clause. The
      MetaSQL states that the <literal>item_number</literal> for the selected
      item must match a specified <literal>item_code</literal>. The term
      <literal>item_code</literal> is a parameter. We can set different values
      for the <literal>item_code</literal> parameter using the MetaSQL
      Editor—and then run the query to test the results.</para>
      <para>However, before we run the query, we must first define the
      parameter <literal>item_code</literal> and assign it a value.</para>
    </section>
    <section>
      <title>Defining Parameters and Values</title>
      <para>Earlier in this chapter we discussed parameters and how they
      enable reports to respond to dynamic conditions presented by application
      users. The MetaSQL Editor enables you to simulate these dynamic
      conditions, by defining parameters and assigning values to them.</para>
      <para>Let’s assign a value to the parameter we entered in our MetaSQL
      example—namely, the parameter <literal>item_code</literal>. In our
      example, we are simulating a situation in which an xTuple user inputs an
      <literal>item_code</literal>. The <literal>item_code</literal>, in turn,
      corresponds to an <literal>item_number</literal> in the
      <literal>item</literal> table.</para>
      <para>Before we can test our MetaSQL, we must first create the parameter
      <literal>item_code</literal>. To create a parameter, we open the
      <guimenuitem>Parameter List</guimenuitem> option from the
      <guimenu>View</guimenu> menu. The following screen will appear:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_211_ParamList-1.png"/>
            </imageobject>
            <caption>Parameter List</caption>
          </mediaobject>
        </screenshot></para>
      <note>
        <para>Parameters will be saved only for the duration of the current
        MetaSQL Editor session. Once the MetaSQL Editor is closed, any saved
        parameters will be erased.</para>
      </note>
      <para>The Parameter List screen displays information on all parameters
      which have been created for testing purposes, including active status,
      parameter name, data type, and value.</para>
      <para>To create a new parameter, select the <guibutton>NEW</guibutton>
      button. The following screen will appear:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_212_NewParamName.png"/>
            </imageobject>
            <caption>Enter new parameter</caption>
          </mediaobject>
        </screenshot></para>
      <para>When entering a new parameter, you are presented with the
      following options:</para>
      <variablelist>
        <varlistentry>
          <term>Name</term>
          <listitem>
            <para>Enter a name to identify the parameter. The names of
            parameters should correspond to parameter names referenced in your
            test queries.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Type</term>
          <listitem>
            <para>Select the appropriate data type from the list of available
            data types. Data types are defined on the database—and may vary
            from column to column. To be successful, your selection must match
            the data type for the target column in the database. In our
            example, the target column is <literal>item_number</literal>. The
            data type for this column is <literal>text</literal> in the
            MetaSQL Editor. The <literal>text</literal> data type corresponds
            to the <literal>string</literal> type.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>To the far right of the screen, the following buttons are
      available:</para>
      <variablelist>
        <varlistentry>
          <term>OK</term>
          <listitem>
            <para>Select to save the entered values.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>CANCEL</term>
          <listitem>
            <para>Select to cancel the transaction and return to the parameter
            list.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>After we have entered the appropriate values and selected the
      <guilabel>OK</guilabel> button, the following screen appears:</para>
      <para id="i571179"><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_213_NewParamValue.png"/>
            </imageobject>
            <caption>Specify value for parameter</caption>
          </mediaobject>
        </screenshot></para>
      <para>As you can see, we are asked to enter a value for the parameter.
      In this case, we enter <literal>YTRUCK1</literal>. This is an
      <literal>item_number</literal> from our sample database. By entering
      that value here, we are linking the parameter
      <literal>item_code</literal> to <literal>item_number</literal>
      <literal>YTRUCK1</literal>. Selecting the <guibutton>OK</guibutton>
      button saves our information.</para>
      <para>Back on the Parameter List window, we can verify the information
      has been entered correctly, as shown in the following screen:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_214_ParamList-2.png"/>
            </imageobject>
            <caption>Parameter List containing sample parameter</caption>
          </mediaobject>
        </screenshot></para>
      <para>Now that we have our sample query and corresponding parameter, we
      are ready to begin our testing.</para>
    </section>
    <section>
      <title>Parsing and Executing a Query</title>
      <para>Before we execute our query, we must first parse it using the
      MetaSQL parser. As we have discussed previously, the MetaSQL parser
      interprets MetaSQL statements embedded in a query, evaluates the
      available parameters, and then produces standard SQL. The resulting
      standard SQL is then sent to the database for processing.</para>
      <para>To parse select the <guimenuitem>Parse Query</guimenuitem> option
      from the <guimenu>Tools</guimenu> menu. The following screen will
      appear:</para>
      <para id="i571430"><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_230_Parse.png"/>
            </imageobject>
            <caption>Parsed query in MetaSQL Editor</caption>
          </mediaobject>
        </screenshot></para>
      <para>Notice that the MetaSQL parser creates a Log Output screen, where
      messages related to the parsing process will be written. In our case, we
      get a "Query parsed." message, which means our MetaSQL was parsed
      successfully.</para>
      <para>Once a query has been parsed, we are ready to execute it.
      Executing a query means the standard SQL produced by the MetaSQL parser
      is sent to the database for processing. To execute a query, select the
      <guimenuitem>Execute Query</guimenuitem> option from the
      <guimenu>Tools</guimenu> menu. The following screen will appear:</para>
      <para id="i571506"><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_235_Result.png"/>
            </imageobject>
            <caption>Results of executed query</caption>
          </mediaobject>
        </screenshot></para>
      <para>When a query is executed successfully, the results will be
      displayed in a Results Output screen. As you can see in the example, the
      value returned in the <literal>item_number</literal> column equals the
      value assigned to the parameter <literal>item_code</literal>.</para>
    </section>
    <section>
      <title>Resulting Standard SQL</title>
      <para>One of the most powerful features of the MetaSQL Editor is the
      ability to view the standard SQL generated by the MetaSQL parser. This
      is the same standard SQL the parser sends to the database for
      processing. This visibility is especially helpful when attempting to
      troubleshoot lengthy queries having complex MetaSQL statements and
      numerous parameters. To view the standard SQL output, select the
      <guimenuitem>Executed SQL</guimenuitem> option from the
      <guimenu>View</guimenu> menu. The following screen will appear:</para>
      <para id="i571700"><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_240_ExecutedQuery.png"/>
            </imageobject>
            <caption>Standard SQL output from MetaSQL parser</caption>
          </mediaobject>
        </screenshot></para>
      <para>As you can see, the MetaSQL parser has stripped the MetaSQL
      elements from the original query to produce standard SQL which can be
      processed by the database.</para>
      <tip>
        <para>If you save your MetaSQL queries to a local file, you can load
        them into the MetaSQL Editor at a later time. Parameter lists may not
        be saved, however.</para>
      </tip>
      <para>This concludes the section on using the MetaSQL Editor. Again, we
      used a very simple query to illustrate the basic mechanics of the
      MetaSQL Editor. We encourage you to test more complex queries and
      parameter lists on your own.</para>
    </section>
  </section>
  <section>
    <title>Report Renderer</title>
    <para>The report renderer generates printed reports from report
    definitions. Like the report writer, the report renderer is a
    multi-platform tool which is available as either a standalone application
    or an embedded version bundled with xTuple. The report renderer is
    designed to connect to PostgreSQL databases; however, the application’s
    source code could be modified to enable connections to other databases, as
    well.</para>
    <tip>
      <para>The standalone report renderer can be used by xTuple users to
      generate custom reports—that is, reports which are not available using
      the xTuple menu structure. This flexibility enables users to extend the
      reporting capabilities of xTuple.</para>
    </tip>
    <para>In this section, we will focus on the standalone report renderer.
    The standalone version gives users the ability to connect to multiple
    databases—and generate custom reports from those databases.</para>
    <section>
      <title>Connecting to a Database</title>
      <para>To open the report renderer, locate the renderer application file
      on your system. It should be installed in a directory along with its
      required support libraries. These support libraries will vary depending
      on your operating system. Once you have opened the file, you will be
      presented with the initial log in screen, as shown in the following
      screenshot:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_254_RenderLog-1.png"/>
            </imageobject>
            <caption>Report renderer Log In screen</caption>
          </mediaobject>
        </screenshot></para>
      <para>As you can see, the server and database information has yet to be
      specified. To specify connection details, select the
      <guibutton>OPTIONS</guibutton> button. The following screen will
      appear:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_255_RendLogOpt.png"/>
            </imageobject>
            <caption>Specifying Database Connection Details</caption>
          </mediaobject>
        </screenshot></para>
      <note>
        <para>The report renderer is designed to connect to PostgreSQL
        databases. However, the application’s source code could be modified to
        enable connections to other databases, as well.</para>
      </note>
      <para>When specifying database connection details, you are presented
      with the following options:</para>
      <variablelist>
        <varlistentry>
          <term>Server</term>
          <listitem>
            <para>Enter the host name for the server you want to connect
            to.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Database</term>
          <listitem>
            <para>Enter the name of the target database.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Port</term>
          <listitem>
            <para>Enter the port number for the target database.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>Once you have entered connection details, the server and database
      information will display on the initial log in screen, as shown
      below:</para>
      <para id="i573090"><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_256_RenderLog-2.png"/>
            </imageobject>
            <caption>Connection details on Log In Screen</caption>
          </mediaobject>
        </screenshot></para>
      <para>Finally, we enter username and password information, then select
      the <guibutton>LOGIN</guibutton> button. Once authentication is
      complete, the report renderer's main application screen will appear, as
      shown below:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_260_RenderMain.png"/>
            </imageobject>
            <caption>Report renderer main application Screen</caption>
          </mediaobject>
        </screenshot></para>
      <para>As you can see, no report definition has been loaded yet. Once a
      report definition is loaded—and parameters defined, if necessary—we can
      run the report and print the results.</para>
      <para>In the next section, we will look at a sample report
      definition—and later we will load this sample into the report
      renderer.</para>
    </section>
    <section>
      <title><emphasis>Ad Hoc</emphasis> Reports</title>
      <para>As we have said, the report renderer can be used to generate
      miscellaneous reports using data stored within PostgreSQL databases. The
      report renderer’s miscellaneous or <emphasis>ad hoc</emphasis> reporting
      capability also extends to xTuple databases, which run on PostgreSQL.
      For xTuple users, this means you can use the report renderer to generate
      your own reports—thereby extending your reporting capability beyond the
      range of standard reports included with the xTuple application.</para>
      <tip>
        <para>The report renderer enables xTuple users to extend their
        reporting capabilities. Use the report renderer to generate
        <emphasis>ad hoc</emphasis>, or custom xTuple reports.</para>
      </tip>
      <para>Before we can demonstrate report renderer functionality, we must
      first identify a report definition to work with. For this exercise, we
      created a simple report definition designed to retrieve basic item
      information from an xTuple database. As the following screenshot shows,
      we created the report "AdHocItemReport" using the standalone OpenRPT
      application:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_600_OpenRPT_AdHocReport.png"/>
            </imageobject>
            <caption>Report definition for Ad Hoc Item Report</caption>
          </mediaobject>
        </screenshot></para>
      <note>
        <para>xTuple users can create report definitions using either the
        embedded report writer or the standalone OpenRPT application. The
        report renderer then uses these report definitions to generate printed
        reports.</para>
      </note>
      <para>As you can tell from the figure, this simple "AdHocItemReport"
      will list items and report on whether they are sold or active. The
      "AdHocItemReport" report is not one of the standard xTuple reports
      available in the application’s menu structure. However, we can retrieve
      this data and generate an ad hoc report when we combine this report
      definition with the standalone report renderer.</para>
      <para>The next screenshot shows the query source the report definition
      will use to retrieve the data from our database:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_610_OpenRPT_Qry.png"/>
            </imageobject>
            <caption>Ad Hoc report definition Query Editor</caption>
          </mediaobject>
        </screenshot></para>
      <para>As you can see in the query source, the <literal>SELECT</literal>
      statement retrieves basic item information from the
      <literal>item</literal> table. Then, MetaSQL is used in the
      <literal>WHERE</literal> clause to introduce two parameters:
      <literal>sold_param</literal> and <literal>active_param</literal>. The
      parameters refer to the report must interpret to accommodate two dynamic
      parameters. These parameters will enable the namely, whether application
      users have marked the item as sold and/or active.</para>
      <note>
        <para>The report displays whether or not an item is sold and whether
        it is active. In the next section we see the query source and
        corresponding SQL query that retrieves the data from the database. As
        part of the SQL we will assign parameters that, when we generate the
        report with the renderer, filter data based on user provided values
        for these two parameters.</para>
      </note>
      <para>Later, using OpenRPT, we will pass runtime parameter values to the
      report definition when we generate its output and in this way control
      the nature of the data displayed on the resulting report.</para>
      <tip>
        <para>To accelerate the creation of any report definition, use the
        MetaSQL Editor to verify the accuracy of your SQL queries. Once
        queries have been validated, you can then copy and paste them into
        your report definition’s query source.</para>
      </tip>
    </section>
    <section>
      <title>Loading Report Definitions</title>
      <para>In this section we will look at a simple <emphasis>ad
      hoc</emphasis> report definition against the xTuple
      <literal>item</literal> table. Keep in mind that you are not restricted
      to xTuple databases and tables when using OpenRPT in conjunction with
      the OpenRPT Renderer. After reviewing a few key aspects of the report
      definition we will look at how to generate the report’s output with the
      OpenRPT Renderer.</para>
      <para>This first step when using the OpenRPT Renderer is opening a
      report definition. Remember, these definitions are created using OpenRPT
      and are saved in XML format.</para>
      <tip>
        <para>XML report definitions may be saved to a network drive. In this
        way many users can have access to a collection of <emphasis>ad
        hoc</emphasis> reports.</para>
      </tip>
      <para>To open an XML report definition file:</para>
      <itemizedlist>
        <listitem>
          <para>Pull down the OpenRPT Renderer <guimenu>File</guimenu>
          menu.</para>
        </listitem>
        <listitem>
          <para>Select the option <guimenuitem>Open</guimenuitem>.</para>
        </listitem>
        <listitem>
          <para>In the operating system’s open file dialogue, locate the
          report definition’s XML file and select it.</para>
        </listitem>
      </itemizedlist>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_257_LoadReport.png"/>
            </imageobject>
            <caption><para>Locating report definition to load into
            renderer</para></caption>
          </mediaobject>
        </screenshot></para>
      <para>The following screenshot shows the renderer after the report
      definition has been loaded:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_261_ReportLoaded.png"/>
            </imageobject>
            <caption><para>Report definition loaded</para></caption>
          </mediaobject>
        </screenshot></para>
      <para>The top half of the OpenRPT Renderer contains a section called
      report information. In it you will see the following information read
      from the report definition's XML file:</para>
      <itemizedlist>
        <listitem>
          <para>Name</para>
        </listitem>
        <listitem>
          <para>Title</para>
        </listitem>
        <listitem>
          <para>Description</para>
        </listitem>
      </itemizedlist>
      <para>Developers of report definitions should utilize the
      <guilabel>Description</guilabel> section of a report definition to
      communicate information about what the report does to those who will use
      it.</para>
    </section>
    <section>
      <title>Adding OpenRPT Renderer Runtime Parameters</title>
      <para>You may recall that when we created our report definition’s SQL,
      we embedded in it (within the MetaSQL tags ‘<literal>&lt;?’</literal>
      and ‘<literal>?&gt;</literal>’ parameters that will accept user defined
      values at run time. After we open an OpenRPT report definition, we must
      define these parameters and set their values before generating the
      report. The report definition we defined contains two parameters:</para>
      <itemizedlist>
        <listitem>
          <para><literal>sold_param</literal></para>
        </listitem>
        <listitem>
          <para><literal>active_param</literal></para>
        </listitem>
      </itemizedlist>
      <para>Let's look at how a parameter is defined and a value
      assigned.</para>
      <section>
        <title>Define Parameter</title>
        <para>After opening the report definition click the
        <guibutton>ADD</guibutton> button. You will see the New Variant
        screen:</para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_670_Render_NewParam_1.png"/>
          </imageobject>
          <caption><para>New Variant screen</para></caption>
        </mediaobject>
        <para>You must enter the exact <guilabel>Name</guilabel> of the
        parameter, as defined in the report definition, and assign it a
        <guilabel>Type</guilabel>. Above we see the
        <literal>sold_param</literal> defined as a type "Bool" (boolean) which
        means it has a true/false value in the database.</para>
        <para>After clicking the <guibutton>OK</guibutton> button, you will be
        prompted to enter a value for the parameter and check whether or not
        it is active.</para>
      </section>
      <section>
        <title>Set Parameter Value</title>
        <para>Below we see the screen that enables us to set a value for the
        parameter we just define. This screen displays after we click the
        <guibutton>OK</guibutton> button on the New Variant screen.</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_680_Render_NewParam_2.png"/>
              </imageobject>
              <caption><para>Setting variant values</para></caption>
            </mediaobject>
          </screenshot>Note that because the parameter was defined as type
        "Bool", we are presented only with the options
        <guimenuitem>True</guimenuitem> of <guimenuitem>False</guimenuitem>
        for the parameter's value.</para>
        <para>It is important to set the parameter as
        <guilabel>Active</guilabel> if you want its value passed to the report
        definition at report run time.</para>
        <para>Clicking the <guibutton>OK</guibutton> button returns you to the
        main screen for the OpenRPT renderer and displays information about
        the parameter(s) in the <guilabel>Parameters</guilabel> section of the
        screen.</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_690_Render_FinishSetup.png"/>
              </imageobject>
              <caption>Two parameters defined along with values</caption>
            </mediaobject>
          </screenshot></para>
      </section>
      <section>
        <title>Changing Parameter Values</title>
        <para>Parameters values may changed by clicking the
        <guibutton>EDIT</guibutton> button found on the main OpenRPT Rendered
        screen. The user first selects a parameter to edit by clicking on it
        and then clicks the <guibutton>EDIT</guibutton> button. The OpenRPT
        Renderer displays the screen that enables the user to change the
        parameter's value or uncheck the <guilabel>Active</guilabel> option to
        deactivate the parameter.</para>
      </section>
      <section>
        <title>Deleting a Parameter</title>
        <para>Parameters may be deleted with the <guibutton>DELETE</guibutton>
        button found on the main OpenRPT Renderer screen. The user first
        selects a parameter to delete by clicking on it and then clicks the
        <guibutton>DELETE</guibutton> button. The OpenRPT Renderer removes the
        parameter from the list of parameters displayed.</para>
        <note>
          <para>Currently parameters are not saved. When the renderer is
          closed, all parameter settings are lost and must be re-entered the
          next time the report definition is opened with the OpenRPT
          Renderer.</para>
        </note>
      </section>
      <section>
        <title>Generating the <emphasis>Ad Hoc</emphasis> Report</title>
        <para>Now that you have:</para>
        <itemizedlist>
          <listitem>
            <para>Connected to the database,</para>
          </listitem>
          <listitem>
            <para>Opened report definition's XML file,</para>
          </listitem>
          <listitem>
            <para>Defined parameters and set their values,</para>
          </listitem>
        </itemizedlist>
        <para>It is possible to render the report's output. Simply:</para>
        <itemizedlist>
          <listitem>
            <para>Pull down the <guimenu>File</guimenu> menu on the main
            OpenRPT Renderer screen.</para>
          </listitem>
          <listitem>
            <para>Select the <guimenuitem>Print</guimenuitem> option.</para>
          </listitem>
          <listitem>
            <para>Choose a printer and start the print job.</para>
          </listitem>
        </itemizedlist>
        <para>Below we see our <emphasis>Ad Hoc</emphasis> item report:</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_695_AdHocReportOutput.png"/>
              </imageobject>
              <caption>Ad Hoc report generated through the OpenRPT
              Renderer.</caption>
            </mediaobject>
          </screenshot></para>
        <para>Above we see that the user, prior to running this report, set
        parameters that show only items that are sold (<emphasis>sold_param =
        true</emphasis>) and that have been set to inactive status
        (<emphasis>active_param = false</emphasis>). The user could return to
        the OpenRPT Renderer and change one or both of the parameter's values
        to generate a different report.</para>
        <tip>
          <para>Utilities exist on the three support client platforms that
          enable the generation of printed output to a .PDF formatted file (as
          seen above) for viewing on-screen.</para>
        </tip>
      </section>
    </section>
  </section>
  <section>
    <title>Watermarks and Background Images</title>
    <para>The xTuple report writer supports two advanced features that enable
    you to make your reports visually appealing and add a level of security
    that makes it easier to determine if a printed report is the original or a
    duplicate. These two features are watermarks and background images.</para>
    <variablelist>
      <varlistentry>
        <term>Watermark</term>
        <listitem>
          <para>A watermark is text that is printed across the background of a
          report and is usually defined with an opacity factor that cause the
          printing to be lighter than the report’s foreground content.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Background Image</term>
        <listitem>
          <para>A background image is similar to a watermark in that it is
          displayed in the background of the report's output and its opacity
          can be controlled. However, as its name implies, a background image
          is graphical, not textual, in nature.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>The use of watermarks and background images is not mutually
    exclusive; a report may employ both. Also, both may be static or dynamic
    in nature. That is to say, a watermark may have a fixed value, or its
    value may be derived from a query source that retrieves it from the
    database. A static background image references a single image for the
    report. A dynamic background image can use a query against the
    <literal>images</literal> table to retrieve a different image (perhaps a
    customer’s logo) based on parameter values passed to the report at
    run-time.</para>
    <para>Below is a report that employees both an static background image and
    a static watermark:</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_400_AReptWithWatermarks.png"/>
          </imageobject>
          <caption>Portion of a sample report showing static background image
          and static watermark</caption>
        </mediaobject>
      </screenshot></para>
    <para>Both watermarks and background images are defined in the report
    properties session. To open this session first open the report writer and
    then the report to which you want to add or change the watermark or
    background image. Next:</para>
    <itemizedlist>
      <listitem>
        <para>Pull down the <guimenu>Document</guimenu> menu.</para>
      </listitem>
      <listitem>
        <para>Click on the <guimenuitem>Properties</guimenuitem>
        option.</para>
      </listitem>
    </itemizedlist>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_400_RptProp1.png"/>
          </imageobject>
          <caption>Report Properties Info tab</caption>
        </mediaobject>
      </screenshot></para>
    <para>The Info tab enables you to provide a descriptive title for your
    report and a detailed description that may, in the future, help others
    understand how your report works or should be used.</para>
    <section>
      <title>Background Images</title>
      <para>Background images are defined on the Report Properties session
      under the <guimenuitem>Background</guimenuitem> tab:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_410_ReptPropBackgroundGeneral.png"/>
            </imageobject>
            <caption>General tab for background images</caption>
          </mediaobject>
        </screenshot></para>
      <para>To enable background images, the <guilabel>Enable Background
      Image</guilabel> box must be checked.</para>
      <para>There are two types of background image: static and dynamic. Our
      example depicts a static background image: one where the image shown
      never changes.</para>
      <para>A dynamic background image can be displayed from the xTuple
      <literal>images</literal> table based on the results of a the SQL in a
      query source. The column field would then reference the
      <literal>image_data</literal> column which contains the image data.
      Company logos, product images, and employee photos, just to name a few,
      can be stored in the <literal>images</literal> table and pulled
      dynamically into a report through the SQL in a query source.</para>
      <para>Within the <guimenuitem>Background</guimenuitem> tab there are
      three sub-tabs: <guimenuitem>General</guimenuitem>,
      <guimenuitem>Layout</guimenuitem>, and <guimenuitem>Static
      Image</guimenuitem>.</para>
      <section>
        <title>General</title>
        <para>The <guimenuitem>General</guimenuitem> tab controls the source
        of the image: static or dynamic. The query source and column, if it is
        a dynamic background image, references the SQL query source and the
        column retrieved by it that contains the image data. The opacity
        slider controls the level of transparency that the background image
        will posses when displayed.</para>
      </section>
      <section>
        <title>Layout</title>
        <para>The <guimenuitem>Layout</guimenuitem> tab for background images
        controls whether the image is shown at its original size (the
        <guilabel>Clip</guilabel> option) or it is stretched (the
        <guilabel>Stretch</guilabel> option) based on the values of the fields
        <guilabel>Width</guilabel> and <guilabel>Height</guilabel>.</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_412_ReptPropBackgroundLayout.png"/>
              </imageobject>
              <caption>Layout tab for background images</caption>
            </mediaobject>
          </screenshot></para>
        <para>Other settings on this tab control the position of the
        background image in the report.</para>
      </section>
      <section>
        <title>Static Image</title>
        <para>The <guimenuitem>Static Image</guimenuitem> tab for background
        images only applies to static background images.</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_416_ReptPropBackgroundStatImage.png"/>
              </imageobject>
              <caption>Static image for display</caption>
            </mediaobject>
          </screenshot></para>
        <para>When you click on the <guibutton>LOAD</guibutton> button, you
        are presented with your operating system's locate file dialogue.
        Selecting the image locally and clicking <guibutton>OK</guibutton>
        returns you to the <guimenuitem>Static Image</guimenuitem> tab and a
        view of the image.</para>
        <note>
          <para>Static background images are embedded in XML that is stored in
          the column <literal>report_source</literal> in the table report. As
          such, when you save a report definition locally in XML format, the
          static image is embedded in it and transported with it.</para>
        </note>
      </section>
    </section>
    <section>
      <title>Watermarks</title>
      <para>Watermarks are defined on the report properties session under the
      <guimenuitem>Watermarks</guimenuitem> tab. Let’s take a look at the
      screen that enable us to control watermarks:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_420_ReptPropBackgrndWatermark.png"/>
            </imageobject>
            <caption>Watermark tab on report properties</caption>
          </mediaobject>
        </screenshot></para>
      <para>Like background images, watermarks can also be static or
      dynamic.</para>
      <para>The value of a dynamic watermark may be provided through the
      results of an SQL query referenced in the fields query source and
      columns. Likewise, the value of a parameter value passed to the report
      at run-time can also be displayed by selecting parameter query in the
      <guilabel>Query Source</guilabel> field and entering the name of the
      parameter in the <guilabel>Column</guilabel> field.</para>
      <para>The characteristics of the watermark, its size, font, and opacity,
      are controlled by the other fields on the
      <guimenuitem>Watermark</guimenuitem> tab.</para>
    </section>
  </section>
  <section>
    <title>Bar Coding</title>
    <para>The two major benefits to bar coding are accuracy and speed during
    data collection. The report writer makes it easy to add bar coded
    information to report definitions. In this section we look at a simple but
    powerful example.</para>
    <para>The photo below is of a wedge type barcode scanner. This type of
    scanner is attached to a PC running the xTuple Client. When a barcode is
    scanned, the information read by the scanner is entered on the screen
    wherever the cursor is currently located. Put another way, a wedge scanner
    is a substitute for the user's manual data entry. Today these scanners are
    durable, inexpensive, and easy to connect.</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_500_Scanner.png"/>
          </imageobject>
          <caption>Low cost barcode scanner</caption>
        </mediaobject>
      </screenshot></para>
    <para>Frequently barcode scanners are used to collect information on the
    shop floor. Below is the xTuple Post Production screen:</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_510_WOPostProd.png"/>
          </imageobject>
          <caption>xTuple Post Production screen</caption>
        </mediaobject>
      </screenshot></para>
    <para>Users posting production are required to enter two pieces of
    information: the work order number and the quantity to post. This
    information is available on the work order's router. But the standard
    router (see below) contains this information only in human readable
    form.</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_520_STDRouter.png"/>
          </imageobject>
          <caption>xTuple work order Routing</caption>
        </mediaobject>
      </screenshot></para>
    <para>The information that we need for posting production is on the
    routing, but in human readable form. Let's look at how easy it is to add
    two addition fields that display this information in barcode
    format.</para>
    <para>Below we see the report definition called Routing:</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_530_RepDefBefore.png"/>
          </imageobject>
          <caption>Routing before barcode added</caption>
        </mediaobject>
      </screenshot></para>
    <para>To added the human readable fields we are interested in at referred
    to on the screen as <literal>wonumber:Head</literal> field and
    <literal>qtyord:Head</literal> field. We will leave these fields as they
    are, but, we will need to move the <literal>wonumber:Head</literal> field
    and its corresponding label up a little to make room for the barcode field
    which we will place underneath it.</para>
    <para>Once we have room on the report definition for the barcode we can
    use the barcode tool to place barcode in the report definition. Below we
    see the Barcode Properties screen:</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_540_FieldDefForBC.png"/>
          </imageobject>
          <caption>Barcode Properties definition for the work order number
          field</caption>
        </mediaobject>
      </screenshot></para>
    <para>There are four critical settings on this screen:</para>
    <variablelist>
      <varlistentry>
        <term>Format</term>
        <listitem>
          <para>You should check which formats your scanner supports. Most
          modern scanners enable auto-selection which means that the scanner
          can read more than one format and determine the format when the
          barcode is scanned. xTuple provides the following standard barcode
          formats: 3 of 9; 3 of 9+; 128; ean13; ean8; upc-a; upc-e.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Query Source</term>
        <listitem>
          <para>We can look at this settings for the human readable
          <literal>wonumber:Head field</literal> field and <literal>qtyord:
          Head field</literal> fields and use that same query for our bar
          coded fields.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Column</term>
        <listitem>
          <para>We can look at this settings for the human readable
          <literal>wonumber:H</literal><literal><literal>ead</literal>
          field</literal> and <literal>qtyord: Head field</literal> fields and
          use that same column for our bar coded fields.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Maximum Length of Value</term>
        <listitem>
          <para>Here we set the number characters wide the work order number
          and quantity ordered could be. Ten and six respectively will work
          for these two barcodes.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>After the addition of our barcode fields the new report definition
    will look something like this:</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_550_ReportDefAfterBC.png"/>
          </imageobject>
          <caption>Routing report after barcode added</caption>
        </mediaobject>
      </screenshot></para>
    <para>Remember when you save to DB to use a grade other than "0" for your
    new routing report definition. To view the new routing, go to the
    <guimenu>W/O - W/O Control</guimenu> menu and select <guimenuitem>Print
    Routing</guimenuitem>. Enter a the work order number for a currently
    released work order and click the <guibutton>PRINT</guibutton> button. The
    new routing looks like this:</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_560_BARCODE_Router.png"/>
          </imageobject>
          <caption>New routing enhances accuracy and speed</caption>
        </mediaobject>
      </screenshot></para>
    <para>Now, a user recording production on the Post Production screen need
    only scan the work order number and the quantity to post from the new
    routing, and click the <guibutton>POST</guibutton> button.</para>
    <para><screenshot>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/C03_510_WOPostProd.png"/>
          </imageobject>
          <caption>Scanning into Post Production screen</caption>
        </mediaobject>
      </screenshot></para>
    <para>As you become more and more familiar with xTuple and the data
    collection screens in it that you use to run your business, pay close
    attention to the xTuple documentation that users rely on to provide that
    data. You will likely find many other opportunities to add bar coded
    fields to report definitions and by doing so, improve the speed and
    accuracy of the information that is collected.</para>
  </section>
  <section>
    <title>Graphing</title>
    <para>The report writer provides the capability to display information
    graphically. In this section we will examine this functionality by looking
    at how an existing report definition defined in the xTuple ERP application
    suite that displays inventory history can be enhanced to show the
    information in both numerical and graphical form.</para>
    <section>
      <title>Graphical Report Output</title>
      <para>The basis for our discussion is an existing report that is
      generated by xTuple in the <guimenu>Inventory Management</guimenu>
      module. The display is called Time-Phased Item Usage Statistics by Item
      and the report is generated by clicking the <guibutton>PRINT</guibutton>
      button.</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_700_GenTimePhaseGraphicReport.png"/>
            </imageobject>
            <caption>Time-Phased Item Usage Statistics report</caption>
          </mediaobject>
        </screenshot></para>
      <para>Data for the report can be viewed prior to initiating the report.
      Above we see eight weeks of historical information for a specified item
      in a specific warehouse. The standard report definition displays this
      same information in a vertical format on a printed page. However, with
      the report writer's graphing capability, we can display the same
      information visually as well.</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_710_OutputTimePhaseGraphicReport.png"/>
            </imageobject>
            <caption>Time-phased data displayed graphically</caption>
          </mediaobject>
        </screenshot></para>
      <para>To do this, the standard report definition was enhanced so that
      the header area at the top was large enough to accommodate the new
      graph. Then, the same columns in the query definition that were used in
      the body of the report to display the period were used to plot the Y
      axis. Likewise, the columns in the query definition that were used to
      display the quantity information (received, issued, etc.) were used to
      define the X axis. Let's take a look under the hood and see how this was
      done.</para>
    </section>
    <section>
      <title>Graphical Report Definition</title>
      <para>The nature of a report definition that displays information
      graphically is fundamentally the same as one that displays information
      textually. Indeed, a report definition that displays numerical
      information is often a good candidate for graphical enhancement.</para>
      <para>Below we see the report definition for the Time Phased Usage
      Statistics By Item screen after the section <guilabel>Report
      Header</guilabel> has been enlarged and a graph object has been added to
      it:</para>
      <para><screenshot>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/C03_720_RepWriterMainDef.png"/>
            </imageobject>
            <caption>Enhanced Report Header</caption>
          </mediaobject>
        </screenshot></para>
      <para>A graph object is added using the graphing tool on the toolbar.
      Start by clicking on the graphing tool. Then, click on the area in the
      section of the report definition where you want the graph to display.
      Next, resize the resulting graph object box with your mouse. Finally,
      double-click on the graph object to define detailed information about
      its behavior.</para>
      <para>We will cover graphing object definition shortly. First, let's
      take a look at the <literal>SELECT</literal> clause in the report's
      query definition to see the origin of the column values that will be
      used to define values and information for the X and Y axes.</para>
      <section>
        <title>Query Source</title>
        <para>The <literal>SELECT</literal> clause in the SQL statement that
        is used in the report's query definition is shown below. It is
        important to note two factors in relation to this query source:</para>
        <itemizedlist>
          <listitem>
            <para>The existing report definition's query source was not
            modified in any way to accommodate the graph.</para>
          </listitem>
          <listitem>
            <para>The SQL utilizes embedded PL/pgSQL (the PostgreSQL
            Procedural Language) functions <literal>summTransR()</literal>,
            <literal>summTransI()</literal>, <literal>summTransS()</literal>,
            <literal>summTransC()</literal> and
            <literal>summTransA()</literal> to actually query the table
            <literal>invhist</literal>.</para>
          </listitem>
        </itemizedlist>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_730_RepDefSQLSelect.png"/>
              </imageobject>
              <caption>SELECT clause contains columns for graphing</caption>
            </mediaobject>
          </screenshot></para>
        <para>Ultimately the query returns values for columns: received,
        issued, sold, scrap, adjustments, and period. These will be used in
        the graph's definition to supply the dynamic data upon which the
        resulting graph will render the information visually.</para>
      </section>
      <section>
        <title>Color Definitions</title>
        <para>Colors must be defined for each report writer report definition.
        We will assign our color definitions to the bars, lines, points that
        define to display the graph.</para>
        <para>To define colors:</para>
        <itemizedlist>
          <listitem>
            <para>Pull down the report writer's <guimenu>Document</guimenu>
            menu.</para>
          </listitem>
          <listitem>
            <para>Click on the option <guimenuitem>Color
            Definitions</guimenuitem>.</para>
          </listitem>
        </itemizedlist>
        <para>You will see the Color Definitions screen:</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_740_ColorDef_1.png"/>
              </imageobject>
              <caption>Assigning names to bars, lines, and points</caption>
            </mediaobject>
          </screenshot></para>
        <para>The Color Definitions screen enables you to add, edit, and
        delete a color. To add a color, click the <guibutton>ADD</guibutton>
        button. The report writer displays the Color Editor screen. You may
        define a color in two ways:</para>
        <itemizedlist>
          <listitem>
            <para>If you know the levels of red, green, and blue that define
            the color you want simply enter the color's name, fill in the
            values in the <guilabel>Components</guilabel> fields, and click
            the <guibutton>OK</guibutton> button.</para>
          </listitem>
          <listitem>
            <para>You may also have the component values filled in for you by
            entering the name for your color and clicking the
            <guibutton>COLOR</guibutton> button. This displays the Select
            Color screen which provides a color palette.</para>
          </listitem>
        </itemizedlist>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_745_ColorDef_2.png"/>
              </imageobject>
              <caption>Selecting Colors</caption>
            </mediaobject>
          </screenshot></para>
        <para>You may use the color palette to select the exact color you want
        to define. When you click the <guibutton>OK</guibutton> button, you
        are returned to the Color Editor screen. The color component values
        are filled in for you based on your selection.</para>
      </section>
    </section>
    <section>
      <title>Defining the Graphing Object</title>
      <para>Now that we have looked at the query source and identified the
      columns that will provide the data we want to graph, and we have defined
      colors that we will associate with bars, lines, and points in our graph,
      we can define the details of our graphing object. Double-clicking on the
      graph object we placed in our report definition displays a dialogue with
      four tabs. Let's take a look at each:</para>
      <section>
        <title>Graph Editor General Tab</title>
        <para>The most significant aspect of the
        <guimenuitem>General</guimenuitem> tab is that it is the place where
        we link our graph object to a query source. We also can precisely
        control the size and location of the graph on the report give it a
        title and assign a base font that can be used throughout the rest of
        the graph object's definition or overridden by exception.</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_750_GraphEd_General.png"/>
              </imageobject>
              <caption>Graph Editor General tab</caption>
            </mediaobject>
          </screenshot></para>
        <para>The <guimenuitem>Graph Editor</guimenuitem> tab provides the
        following options:</para>
        <variablelist>
          <varlistentry>
            <term>Query Source</term>
            <listitem>
              <para>From the pull down list select the query source that
              provides the columns containing the values you want
              graphed.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Position/Size</term>
            <listitem>
              <para>It is easiest to simply drag the graph object in the
              report definition and resize it with your mouse. However, for
              very precise control you may enter X and Y coordinates for the
              location and a width and height defined in inches.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Base Font</term>
            <listitem>
              <para>You may click the <guibutton>FONT</guibutton> button to
              define the characteristics of a base font for your graph. Then,
              on other tabs in the Graph Editor window, simply check
              <guilabel>Use Base Font</guilabel> to select it for use on that
              element of the graph.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Title</term>
            <listitem>
              <para>Enter the title you want to appear above (but within) your
              graph.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>Next we will define the <guimenuitem>Data Axis</guimenuitem>
        tab.</para>
      </section>
      <section>
        <title>Graph Editor Data Axis Tab</title>
        <para>The <guimenuitem>Data Axis</guimenuitem> tab in the Graph Editor
        defines your graph's X axis.</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_752_GraphEd_DataAxis.png"/>
              </imageobject>
              <caption>Graph Editor Data Axis tab</caption>
            </mediaobject>
          </screenshot></para>
        <para>You may define the following information in the
        <guimenuitem>Data Axis</guimenuitem> tab:</para>
        <variablelist>
          <varlistentry>
            <term>Data Axis Labels</term>
            <listitem>
              <para>The <guilabel>Column</guilabel> field in this section
              refers to columns that are the query source you referenced under
              the <guimenuitem>General</guimenuitem> tab. This column contains
              the dynamic data you want displayed along the bottom of the X
              axis. In our example, the column <literal>period</literal>
              contains the date for each period that will be displayed in our
              time-series graph of inventory activity.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Data Axis Title</term>
            <listitem>
              <para>This section enables you to provide a static description
              for the X axis that displays along its base.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>Both sections under the <guimenuitem>Data Axis</guimenuitem> tab
        enable you to select the base font defined under the
        <guimenuitem>General</guimenuitem> tab, or, leave the option unchecked
        and use the <guibutton>FONT</guibutton> button to specify a different
        font and size.</para>
        <para>Now that the X axis is defined, it is time to define the static
        information and other parameters that control the Y axis.</para>
      </section>
      <section>
        <title>Graph Editor Value Tab</title>
        <para>The Graph Editor's <guimenuitem>Value Axis</guimenuitem> tab
        enables you to define properties of a graph's Y axis.</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_754_GraphEd_ValueAxis.png"/>
              </imageobject>
              <caption>Graph Editor Value tab</caption>
            </mediaobject>
          </screenshot></para>
        <para>There are two main sections in the <guimenuitem>Value
        Axis</guimenuitem> tab:</para>
        <variablelist>
          <varlistentry>
            <term>Min/Max</term>
            <listitem>
              <para>The <guilabel>Min</guilabel>/<guilabel>Max</guilabel>
              values control the minimum and maximum value that will for
              displayed for a graphed element. If the values are set to "0"
              and <guilabel>Expand Min/Max if needed</guilabel> is checked,
              the limits of the Y axis will equal largest and smallest graphed
              element.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Value Axis Title</term>
            <listitem>
              <para>The value of the <guilabel>Title</guilabel> field is
              static and will display vertically along the Y axis of the
              graph.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>Both sections under the <guimenuitem>Value Axis</guimenuitem>
        tab enable you to select the base font defined under the
        <guimenuitem>General</guimenuitem> tab, or, leave the option unchecked
        and use the <guibutton>FONT</guibutton> button to specify a different
        font and size.</para>
      </section>
      <section>
        <title>Graph Editor Series Tab</title>
        <para>The <guimenuitem>Series</guimenuitem> tab in the Graph Editor
        enables you to define one or more series that are plotted on your
        graph.</para>
        <para><screenshot>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/C03_756_GraphEd_Series.png"/>
              </imageobject>
              <caption>Graph Editor Series tab</caption>
            </mediaobject>
          </screenshot></para>
        <para>To establish a series click the <guibutton>NEW</guibutton>
        button and then fill in the following:</para>
        <variablelist>
          <varlistentry>
            <term>Name</term>
            <listitem>
              <para>Assign your new series a descriptive name. This name is
              for internal reference only and is not displayed on the
              graph.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Column</term>
            <listitem>
              <para>Link your series to a column in the query source (linked
              to the graph under the <guimenuitem>General</guimenuitem> tab)
              that contains the information you want graphed.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Color</term>
            <listitem>
              <para>Select from the drop down list a color that you defined
              earlier. You may also click the <guibutton>EDIT</guibutton>
              button and define one or more new colors.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Style</term>
            <listitem>
              <para>Check one or more styles to define how the data will
              display in the graph:</para>
              <variablelist>
                <varlistentry>
                  <term>Bars</term>
                  <listitem>
                    <para>Displays the series in bar format, or stacked bars
                    for multiple series defined as bars.</para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>Lines</term>
                  <listitem>
                    <para>Displays the series in line format.</para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term>Points</term>
                  <listitem>
                    <para>Displays the series as a point on the graph.</para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>If you want to continue by adding another series, click the
        <guibutton>NEW</guibutton> button. The series you are defining is
        saved and all values cleared so you can defined the new series'
        properties.</para>
        <para>If you are done entering series information, you may click the
        <guibutton>OK</guibutton> button to exit the Graph Editor, or click on
        another tab under it.</para>
        <para>This completes the mechanics for defining a graph in the report
        writer. Earlier in this section we saw the output of a report with an
        embedded graph. The definition process was easy and straight forward.
        The graphing capability enables you to quickly enhance existing
        reports or define new reports that improve how complex information is
        presented to users.</para>
      </section>
    </section>
  </section>
</chapter>
